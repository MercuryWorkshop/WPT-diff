import {
	ResultAsync,
	errAsync as nErrAsync,
	okAsync as nOkAsync,
} from "neverthrow";
import type { ChromeWPTApiResponse, ChromeWPTReport } from "#types/chrome.d.ts";

export interface GetTestPathsOptions {
	wptUrls: {
		test: string;
		api: string;
	};
	debug?: boolean;
	logger?: {
		debug: (message: string) => void;
		warn: (message: string) => void;
	};
}

export interface ChromeTestData {
	testPaths: Array<{ test: string }>;
	chromeReportData: ChromeWPTReport;
}

export async function getWPTTestPaths(
	options: GetTestPathsOptions,
): Promise<ResultAsync<ChromeTestData, string>> {
	const { logger = { debug: () => {}, warn: () => {} } } = options;
	const getRunsApiEndpoint = `${options.wptUrls.api}/api/run?label=master&label=stable&product=chrome&aligned`;
	logger.debug(
		`Fetching latest Chrome Linux results from the WPT API ${getRunsApiEndpoint}`,
	);
	const latestChromeRespRes = await ResultAsync.fromPromise(
		fetch(getRunsApiEndpoint),
		(err) => `Failed to fetch WPT Results: ${err}`,
	);
	if (latestChromeRespRes.isErr()) return nErrAsync(latestChromeRespRes.error);
	const latestChrome = latestChromeRespRes.value;

	let chromeData: ChromeWPTApiResponse;
	try {
		chromeData = (await latestChrome.json()) as ChromeWPTApiResponse;
	} catch (rawErr) {
		const err = rawErr instanceof Error ? rawErr.message : String(rawErr);
		return nErrAsync(`Failed to parse the WPT Results as JSON: ${err}`);
	}

	// Validate Chrome API response if validator is available
	/*
	let validateChromeWPTApiResponse:
		| typeof import(
				// @ts-ignore: This is generated by `pnpm generate:validators`
				"../generatedValidators/chromeReportValidator.js"
			).validateChromeWPTApiResponse
		| null = null;
	try {
		const validatorModule = await import(
			// @ts-ignore: This is generated by `pnpm generate:validators`
			"../generatedValidators/chromeReportValidator.js"
		);
		validateChromeWPTApiResponse =
			validatorModule.validateChromeWPTApiResponse;
	} catch (err) {
		if (err instanceof Error && err.message.includes("Cannot find module")) {
			if (options.debug) {
				logger.warn(
					"Chrome API response validator not generated. Continuing without runtime type validation",
				);
			}
		}
	}
	if (validateChromeWPTApiResponse) {
		const chromeApiValidationRes = validateChromeWPTApiResponse(chromeData);
		if (chromeApiValidationRes.success) {
			logger.debug("Chrome WPT API response validation succeeded");
		} else {
			const errCount = chromeApiValidationRes.errors?.length || 0;
			const errorDetails = options.debug 
				? `\n${JSON.stringify(chromeApiValidationRes.errors, null, 4)}`
				: "";
			return nErrAsync(
				`Invalid Chrome WPT API response: ${errCount} validation errors${errorDetails}`,
			);
		}
	}
	*/
	if (!("raw_results_url" in chromeData))
		return nErrAsync(
			"Failed to find the raw results URL as expected for the latest Chrome results",
		);
	const chromeReportRes = await ResultAsync.fromPromise(
		fetch(chromeData.raw_results_url),
		() =>
			`Failed to get the fetch the raw results URL found in the latest Chrome Linux run ${chromeData.raw_results_url}`,
	);
	if (chromeReportRes.isErr()) return nErrAsync(chromeReportRes.error);
	const chromeReport = chromeReportRes.value;
	let reportData: ChromeWPTReport;
	try {
		reportData = (await chromeReport.json()) as ChromeWPTReport;
	} catch (rawErr) {
		const err = rawErr instanceof Error ? rawErr.message : String(rawErr);
		return nErrAsync(
			`Failed to parse the WPT Report for the latest Chrome Linux run: ${err}`,
		);
	}

	// Validate Chrome report data if validator is available
	/*
	let validateChromeWPTReport:
		| typeof import(
				// @ts-ignore: This is generated by `pnpm generate:validators`
				"../generatedValidators/chromeReportValidator.js"
			).validateChromeWPTReport
		| null = null;
	try {
		const validatorModule = await import(
			// @ts-ignore: This is generated by `pnpm generate:validators`
			"../generatedValidators/chromeReportValidator.js"
		);
		validateChromeWPTReport = validatorModule.validateChromeWPTReport;
	} catch (err) {
		if (err instanceof Error && err.message.includes("Cannot find module")) {
			if (options.debug) {
				logger.warn(
					"Chrome report validator not generated. Continuing without runtime type validation for Chrome reports",
				);
			}
		}
	}
	if (validateChromeWPTReport) {
		const chromeReportValidationRes = validateChromeWPTReport(reportData);
		if (chromeReportValidationRes.success) {
			logger.debug("Chrome WPT report validation succeeded");
		} else {
			const errCount = chromeReportValidationRes.errors?.length || 0;
			const errorDetails = options.debug 
				? `\n${JSON.stringify(chromeReportValidationRes.errors, null, 4)}`
				: "";
			return nErrAsync(
				`Invalid Chrome WPT report: ${errCount} validation errors${errorDetails}`,
			);
		}
	}
	*/
	if (!reportData.results || !Array.isArray(reportData.results)) {
		return nErrAsync("Chrome WPT report does not contain results array");
	}
	let testPaths: {
		test: string;
	}[] = reportData.results;

	return nOkAsync({
		testPaths,
		chromeReportData: reportData,
	});
}
